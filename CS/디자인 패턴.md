## 디자인 패턴

> 디자인 패턴은 개발 중, 자주 발생하는 문제를 해결하기 위해 솔루션을 제공하는 재사용 가능한 템플릿이다.
>
> 디자인 패턴을 사용하면 코드의 재사용성, 가독성, 유지 보수성을 향상시키는 데 도움이 된다.

### 디자인 패턴의 유형

- **생성패턴(Creational Patterns)** : 객체의 생성과 초기화를 다룬다. 객체를 만드는 방법에 대한 패턴이다.<br>
    <details><summary>예시</summary> 

    - **Factory Method**: 객체 생성을 캡슐화하고 서브 클래스에서 어떤 클래스의 인스턴스를 생성할지를 결정하는 패턴이다.

    - **Abstract Factory**: 관련된 여러 개체 팩토리를 생성하는 인터페이스를 제공하는 패턴으로, 관련된 객체군을 생성한다.

    - **Singleton**: 애플리케이션 내에서 오직 하나의 인스턴스를 가지도록 하는 패턴으로, 공유 리소스에 접근할 때 주로 사용된다.

    - **Builder**: 복잡한 객체의 생성 과정을 단순화하고 유연하게 만드는 패턴이다.

    - **Prototype**: 객체를 복제하여 새로운 객체를 생성하는 패턴으로, 기존 객체를 기반으로 새로운 객체를 만든다.
    </details>


- **구조패턴(Structural Patterns)** : 객체와 클래스를 조합해 더 큰 구조를 만드는 방법을 다룬다. 객체들의 구성이나 클래스들의 구성을 다루는 패턴이다.<br>
    <details><summary>예시</summary> 

    - **Adaptor**: 인터페이스 호환성 문제를 해결하기 위해 클래스를 감싸고 새로운 인터페이스를 제공하는 패턴이다.

    - **Bridge**: 추상화와 구현을 분리하여 두 개의 독립된 계층으로 만드는 패턴이다.

    - **Composite**: 객체와 객체 그룹을 동일한 방법으로 처리할 수 있게 하는 패턴으로, 트리 구조를 만든다.

    - **Decorator**: 객체에 동적으로 새로운 책임을 추가하는 패턴으로, 객체의 기능을 확장한다.

    - **Facade**: 복잡한 서브시스템을 간단한 인터페이스로 래핑하여 클라이언트에게 제공하는 패턴이다.

    - **Flyweight**: 객체의 공유 인스턴스를 통해 메모리 사용량을 최적화하는 패턴이다.

    - **Proxy**: 다른 객체에 대한 대체자를 제공하여 객체에 대한 접근을 제어하는 패턴이다.
    </details>


- **행동패턴(Behavioral Patterns)** : 객체나 클래스 사이의 알고리즘, 역할, 책임, 상태등을 다룬다. 객체들 사이의 상호작용을 다루는 패턴이다. <br>
    <details><summary>예시</summary>

  - **Command**: 요청을 객체로 캡슐화하여 실행 취소, 다시 실행 및 큐 처리를 지원하는 패턴이다.

  - **Interpreter**: 언어의 문법을 정의하고 해석하는 패턴으로, 특정 언어의 해석기를 구현한다.

  - **Iterator**: 집합 객체의 요소를 순차적으로 접근하는 패턴으로, 반복을 단순화한다.

  - **Mediator**: 객체 간의 상호 작용을 캡슐화하여 느슨한 결합을 촉진하는 패턴이다.

  - **Memento**: 객체의 내부 상태를 캡슐화하여 나중에 복원할 수 있도록 하는 패턴이다.

  - **Observer**: 한 객체의 상태 변화를 다른 객체에게 통지하는 패턴으로, 주로 이벤트 처리에 사용된다.

  - **State**: 객체의 상태를 캡슐화하고 상태에 따라 행동을 변경하는 패턴이다.

  - **Strategy**: 여러 알고리즘을 정의하고 각각을 캡슐화하여 교환 가능하도록 만드는 패턴이다.

  - **Template Method**: 일부 알고리즘 단계를 서브 클래스로 미루는 패턴으로, 알고리즘의 뼈대를 정의한다.

  - **Visitor**: 객체 구조를 순회하고 각 요소에 대한 작업을 캡슐화하는 패턴으로, 새로운 작업을 추가하기 쉽다.
    </details>

### 디자인 패턴의 장점

1. **재사용성** : 디자인 패턴은 검증된 해결책을 제공하기 때문에, 이를 사용하여 반복적으로 비슷한 문제에 대한 해결책을 개발할 필요가 없다. 그렇기 때문에 코드의 재사용성이 높아지고 개발 시간을 단축할 수
   있다.


2. **유지 보수성** : 디자인 패턴은 코드의 구존을 개선하기 때문에 유지 보수가 더 쉬워진다. 각 패턴은 특정 목적에 맞게 설계되어 있으므로, 구조화 되어 코드 변경이 용이해지고 가독성이 향상된다.


4. **유연성** : 디자인 패턴은 코드의 구조를 개선하고 더 효율적으로 만들어 주기 때문에, 코드의 유연성이 높아진다. 새로운 요구 사항이나 변경 사항에 대한 대응력을 높이고, 코드 변경에 따른 비용을 최소화 할
   수 있다.


5. **성능향상** : 디자인 패턴은 반복적인 코드 작성을 최소화 하여 성능을 향상시킬 수 있다. 코드 중복이 감소하고, 재사용성이 높아지므로 더 효율적인 코드를 작성할 수 있다.


6. **표준화** : 디자인 패턴은 개발 프로세스에서 의사소통과 협업을 더 쉽게 만들어주며, 전체 소프트웨어 개발 산업에서의 일관성을 유지하는 데 도움이 된다.

### 디자인 패턴의 단점

1. **복잡성** : 디자인 패턴은 일반적으로 다른 클래스와 객체와의 상호작용을 추가하므로 클래스 간의 관계가 더 복잡해질 수 있다.


2. **오용** : 디자인 패턴이 많이 사용되면 개발자들은 간단한 문제를 복잡하게 해결하려고 시도할 수 있다. 이는 프로그램의 효율성을 저하시키고 유지 보수를 어렵게 만들 수 있다.


3. **부적절한 적용** : 디자인 패턴을 잘못 적용하면 문제를 더 복잡하게 만들 수 있다. 각 패턴은 특정한 문제 해결을 위해 고안되었으므로, 그 패턴이 해결하려는 문제와 일치하지 않는 다른 문제에 적용하면
   예상치 못한 결과가 발생할 수 있다.


4. **추가 비용** : 디자인 패턴을 구현하려면 일반적으로 코드의 복잡성이 증가하며, 더 많은 시간과 노력이 필요하다. 