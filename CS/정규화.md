## 데이터베이스 정규화(Normalization)
> 정규화란 데이터베이스 설계 과정에서 중복 데이터를 최소화하고, 데이터의 무결성을 유지하기 위한 프로세스이다. 정규화를 통해 데이터베이스 테이블을 여러개의 릴레이션(테이블)으로 분할하고, 각 릴레이션 간의 관계를 정의함으로써 데이터를 더 효율적으로 저장하고 관리한다.

## 정규화의 장/단점
**장점**
- 정규화는 데이터의 중복을 최소화하고 갱신 시 데이터 무결성을 유지하기 쉽게 만든다.
- 중복 데이터를 제거하므로 데이터베이스의 용량을 줄일 수 있다.
- 정규화된 데이터베이스는 데이터 변경 및 삭제가 더 쉽고 안정적으로 이루어진다. 데이터의 일부만 수정하거나 삭제할 수 있으므로 에러 가능성이 낮아진다.
- 정규화는 데이터베이스 구조를 명확하게 정의하고 테이블 간의 관계를 명확하게 만들어 관리하기 쉽게 만든다.

**단점**
- 높은 정규화 수준은 데이터베이스 설계를 복잡하게 만들 수 있다. 테이블이 많아지고 복잡한 관계를 관리해야 하므로 개발 및 유지 보수 비용이 늘어날 수 있다.
- 과도한 정규화는 데이터 검색 시 조인 연산을 증가시킬 수 있으며 이로 인해 성능 저하가 발생할 수 있다.

## 정규화 단계

### * **제 1 정규화(1NF)**
- 각 컬럼은 원자값(Atomic Value)을 가져야 한다.
- 즉, 모든 컬럼은 하나의 값만을 포함해야 하며, 다중 값 속성이나 배열과 같은 복합 데이터를 하나의 열에 저장하지 않아야 한다.

예시)

| 주문번호 | 고객이름 | 주문상품       |
|---------|------|---------------|
| 1       | 홍길동  | 노트북, 스마트폰 |
| 2       | 이순신  | 태블릿        |

위와같은 테이블을 아래와 같이 적용해야 제 1 정규화 규칙을 만족한다.

| 주문번호 | 고객이름 | 주문상품       |
|------|------|---------------|
| 1    | 홍길동  | 노트북 |
| 1    | 홍길동  | 스마트폰|
| 3    | 이순신  | 태블릿        |

---

### * **제 2 정규화(2NF)**
- 1NF를 만족하면서, 부분적으로 종속되는 데이터를 분리하여 각각의 테이블로 만든다.
- 이를 위해 부분 종속성을 제거하고 관련된 데이터를 별도의 테이블로 분리한다.

예시) 아래와 같이 테이블을 분리한다.

주문테이블:

| 주문번호 | 고객이름 |
|---------|------|
| 1       | 홍길동  |
| 2       | 이순신  |

주문상품 테이블:

| 주문번호 | 주문상품       |
|---------|---------------|
| 1       | 노트북        |
| 1       | 스마트폰     |
| 2       | 태블릿        |

---

### * **제 3 정규화(3NF)**
- 2NF를 만족하면서, 이행적 종속성을 제거한다.
- 이를 위해 이행적 종속성을 가지는 열을 다른 테이블로 분리한다.
  - **이행적 종속성이란?** A->B, B->C 가 성립할 때 A->C가 성립되는 것을 의미한다.

예시)

주문상품 테이블:

| 주문번호 | 상품번호 | 상품이름 |
|---------|---------|---------|
| 1       | 101     | 노트북  |
| 1       | 102     | 스마트폰 |
| 2       | 103     | 태블릿  |

위와 같은 테이블에서 상품 번호와 상품 이름은 key값이 아닌 컬럼임에도 불구하고 종속관계가 성립된다.
따라서 아래와 같이 상품 테이블로 분리할 수 있다.

상품 테이블:

| 상품번호 | 상품이름 |
|---------|---------|
| 101     | 노트북  |
| 102     | 스마트폰 |
| 103     | 태블릿  |

---

### * **보이스코드 정규화(BCNF)**
- 3NF를 만족하면서, 모든 결정자가 후보키(Candidate Key) 집합에 속해야한다. 
- 모든 결정자에 대해 비 후보 키(Non-key) 속성이 아무 것도 이행적으로 종속되어서는 안 된다. 즉, 후보키 집합에 없는 칼럼이 결정자가 되어서는 안된다는 뜻이다.

예시)

고객 주문 테이블:

| 주문번호 | 고객이름 | 주문상품       |
|---------|------|---------------|
| 1       | 홍길동  | 노트북, 스마트폰 |
| 2       | 이순신  | 노트북        |

위의 테이블에서 결정자를 확인해보면 아래와 같다.
- 주문번호 : 후보 키의 일부
- 고객이름 : 후보 키의 일부
- 주문상품 : 비 후보 키 속성
여기서 주문상품은 주문번호와 고객이름에 이행적으로 종속되어 있다. 즉, 주문번호와 고객이름을 알면 주문상품을 결정할 수 있다. 그러므로 BCNF를 만족하지 않는다.
BCNF를 적용하기 위해 아래와 같이 테이블을 분할할 수 있다.

주문 테이블:

| 주문번호 | 고객이름 |
|---------|------|
| 1       | 홍길동  |
| 2       | 이순신  |

주문상품 테이블:

| 주문번호 | 주문상품       |
|---------|---------------|
| 1       | 노트북        |
| 1       | 스마트폰     |
| 2       | 노트북        |

위와같이 테이블을 분리하면 주문상품은 주문 번호에 의존하며, BCNF를 만족한다. 즉, 모든 결정자가 후보 키에 속하며 이행적 종속성이 없다.

---

### * **제 4 정규화(4NF)**
1. BCNF를 만족해야 한다.
2. 다치 종속(Multi-valued Dependency)이 없어야 한다.

### * **제 5 정규화(5NF)**
1. 4NF를 만족해야 한다.
2. 조인 종속(Join dependency)이 없어야 한다.
3. 조인 연산을 했을 때 손실이 없어야 한다.


![AdditionalImage](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fd9KQbK%2Fbtrj0KexV5J%2F2RH6az0sCEuWawlLLlhzhk%2Fimg.png)

통상적으로 정규화는 BCNF까지 하는 경우가 많다. 그 이상의 높은 단계 정규화를 할 경우 정규화의 단점이 나타날 수 있기 때문이다.

참고 : https://code-lab1.tistory.com/48